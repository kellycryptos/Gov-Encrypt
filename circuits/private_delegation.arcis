// circuits/private_delegation.arcis
circuit PrivateDelegation {
    input delegation_matrix: [[u64]]; // [N][N] 1 if i delegates to j
    input raw_reputation: [u64];      // [N]

    output effective_power: [u64];    // [N]

    def main(delegation_matrix: [[u64]], raw_reputation: [u64]) -> [u64] {
        // Validation: Ensure max 1 delegation per user
        // Compute flow of reputation
        
        let mut power = raw_reputation; // Copy
        
        // Single hop delegation for simplicity in this version
        for i in 0..50 {
            for j in 0..50 {
                if delegation_matrix[i][j] == 1 {
                    // Transfer power from i to j
                     power[j] = power[j] + raw_reputation[i];
                     power[i] = 0; // Delegator loses direct power
                }
            }
        }
        
        return power;
    }
}
