# Gov Encrypt Protocol Architecture

## Overview
Gov Encrypt is a production-grade confidential governance protocol built on Solana and Arcium. It leverages Multi-Party Computation (MPC) to enable private voting, confidential delegation, and encrypted treasury simulations.

## System Components

### 1. Frontend (`/frontend`)
- **Framework**: Next.js 15
- **Role**: User interface for governance interaction.
- **Key Features**:
  - Connects to Solana wallet.
  - Encrypts votes client-side before submission.
  - Fetches simulated risk scores from Relayer.
  - Displays encrypted quorum status.

### 2. Relayer (`/relayer`)
- **Runtime**: Node.js / Express
- **Role**: Bridge between Frontend, Arcium, and Solana.
- **Responsibilities**:
  - **Trigger Simulation**: Accepts simulation requests from frontend (`POST /api/simulate`) and orchestrates Arcium MPC logic.
  - **Quorum Status**: Aggregates and serves encrypted quorum data (`GET /api/quorum`).
  - **Event Listening**: Listens to Solana events (e.g., Proposal Created) to trigger background MPC tasks.

### 3. Solana Program (`/programs/gov-encrypt`)
- **Framework**: Anchor
- **Role**: On-chain state management and verification.
- **Responsibilities**:
  - Store encrypted vote accounts.
  - Verify proof of correct encryption/tally (generated by Arcium).
  - Manage proposal state (Active, Passed, Failed).

### 4. Arcium Circuits (`/circuits`)
- **Language**: Arcis (Arcium DSL)
- **Role**: Define MPC logic.
- **Circuits**:
  - `vote_tally.arcis`: Aggregates encrypted votes without revealing individual choices.
  - `reputation_weighted_quorum.arcis`: Calculates quorum reached based on encrypted reputation scores.
  - `treasury_simulation.arcis`: Simulates proposal impact on treasury risk models.

## Data Flow

### Private Voting
1. **User** selects "Approve/Reject".
2. **Frontend** generates random private key encryption.
3. **Frontend** encrypts vote vector: `Encrypt(Vote, PubKey)`.
4. **Frontend** submits `submit_encrypted_vote` transaction to **Solana**.
5. **Relayer** detects new vote event.
6. **Relayer** triggers **Arcium** node to include vote in tally batch.
7. **Arcium** computes new tally result (encrypted) and proof.
8. **Relayer** submits result update to **Solana**.

### Treasury Simulation
1. **User** requests simulation in Frontend.
2. **Frontend** calls `Relayer` (`POST /api/simulate`).
3. **Relayer** forwards request to **Arcium** cluster.
4. **Arcium** runs MPC simulation using private treasury data and proposal parameters.
5. **Relayer** receives risk score and returns it to **Frontend**.

## Deployment

- **Frontend**: Deployed on Vercel.
- **Relayer**: Deployed as a scalable Node.js service (e.g., AWS ECS, DigitalOcean App Platform).
- **Solana Program**: Deployed on Solana Mainnet/Devnet.
- **Arcium Node**: Managed via Arcium Operator infrastructure.

## Security Model

- **Client-Side Encryption**: Inputs are encrypted before leaving the user's device.
- **MPC Tallying**: Votes are never decrypted individually; only the final sum is reconstructed.
- **Isolation**: Frontend is isolated from backend secrets; Relayer works as a trustless forwarder where possible (though currently orchestrates flow).
